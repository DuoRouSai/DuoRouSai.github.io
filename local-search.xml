<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Typora 小妙招 -- 图片服务器😊</title>
    <link href="/2022/03/28/Typora%20%E5%B0%8F%E5%A6%99%E6%8B%9B%20--%20%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/03/28/Typora%20%E5%B0%8F%E5%A6%99%E6%8B%9B%20--%20%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Typora-小妙招-–-图片服务器-😊"><a href="#Typora-小妙招-–-图片服务器-😊" class="headerlink" title="Typora 小妙招 – 图片服务器 😊"></a>Typora 小妙招 – 图片服务器 😊</h2><h3 id="01-前言"><a href="#01-前言" class="headerlink" title="01 前言"></a>01 前言</h3><p><code>Typora</code> 是当今程序猿笔记利器，当我们需要插图片在笔记中，保存其实是本地图片。一旦你上传到自己播客上面，就会发现图片显示不出来，非常麻烦。这边教大家配置一个图片服务器，使用 <code>sm.ms</code> 作为图床</p><blockquote><p>Typora V0.11.17</p></blockquote><h3 id="02-教程"><a href="#02-教程" class="headerlink" title="02 教程"></a>02 教程</h3><p>选择 sm.ms 作为图床,官网地址：<a href="https://sm.ms/">https://sm.ms</a></p><p>特点：永久存储免注册，图片链接支持 https，可以删除上传的图片，提供多种图片链接格式，目前免费用户无法使用香港节点因此速度比较慢，有时候可能上传失败。</p><p>图片上传限制：每个图片最大 5M，每次最多上传 10 张</p><ol><li><p>注册或登陆 sm.ms</p><p>​ <a href="https://sm.ms/login">https://sm.ms/login</a></p></li><li><p>生成 token</p><p><img src="https://s2.loli.net/2022/03/17/Ym7XfbrlZVjdEhv.png" alt="image-20220317225046857"></p></li><li><p>配置 token</p><p>进入<a href="https://sm.ms/home/apitoken">API Access - SM.MS | Dashboard</a></p><p><img src="https://s2.loli.net/2022/03/17/m4aX9PZvYwbc5lS.png" alt="image-20220317225253731"></p><p>回到 Typora 配置</p><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220317225444609.png" alt="image-20220317225444609"></p><p>按照图片顺序，配置 config</p><p><img src="https://s2.loli.net/2022/03/17/TdfZnEJyoaIXHVm.png" alt="image-20220317225658734"></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uploader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;smms&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//传图床为 SM.MS,</span><br>    <span class="hljs-attr">&quot;smms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxx&quot;</span> <span class="hljs-comment">//这里面的token换成刚刚生成的 sm.ms 的token</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>注意修改后重启软件 !!!</p></li></ol><p><strong>效果预览</strong>:</p><p>将图片复制到 Typora ,就自动上传</p><p><img src="https://s2.loli.net/2022/03/17/xMtPjqCZ7mfJiAU.png" alt="image-20220317230130170"></p><p><strong>大功告成！！！</strong> 💕</p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20220318141602372.png" alt="image-20220318141602372"></p>]]></content>
    
    
    <categories>
      
      <category>Typora</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stopPropagation 和 stopImmediatePropagation区别✌️</title>
    <link href="/2022/03/28/stopPropagation%20%E5%92%8C%20stopImmediatePropagation%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/28/stopPropagation%20%E5%92%8C%20stopImmediatePropagation%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="stopPropagation-和-stopImmediatePropagation-区别-✌️"><a href="#stopPropagation-和-stopImmediatePropagation-区别-✌️" class="headerlink" title="stopPropagation 和 stopImmediatePropagation 区别 ✌️"></a>stopPropagation 和 stopImmediatePropagation 区别 ✌️</h1><h3 id="01-名词解释"><a href="#01-名词解释" class="headerlink" title="01 名词解释"></a>01 名词解释</h3><p>✔️<strong>event.stopPropagation ：</strong>比较常见，用于停止冒泡，阻止事件在 DOM 中继续冒泡。</p><p>✔️<strong>event.stopImmediatePropagation:</strong> 阻止 click 事件冒泡,并且阻止 p 元素上绑定的其他 click 事件的事件监听函数的执行.</p><h3 id="02-实践小例子"><a href="#02-实践小例子" class="headerlink" title="02 实践小例子"></a>02 实践小例子</h3><p>💻 动动小手实践下,有助于理解哦…</p><p>// 摘自 MDN</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccf</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#cfc</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="language-javascript">      p.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是p元素上被绑定的第一个监听函数&#x27;</span>)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-literal">false</span></span><br><span class="language-javascript">      )</span><br><span class="language-javascript"></span><br><span class="language-javascript">      p.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是p元素上被绑定的第二个监听函数&#x27;</span>)</span><br><span class="language-javascript">          event.<span class="hljs-title function_">stopImmediatePropagation</span>()</span><br><span class="language-javascript">          <span class="hljs-comment">// 执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-literal">false</span></span><br><span class="language-javascript">      )</span><br><span class="language-javascript"></span><br><span class="language-javascript">      p.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是p元素上被绑定的第三个监听函数&#x27;</span>)</span><br><span class="language-javascript">          <span class="hljs-comment">// 该监听函数排在上个函数后面，该函数不会被执行</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-literal">false</span></span><br><span class="language-javascript">      )</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是div元素,我是p元素的上层元素&#x27;</span>)</span><br><span class="language-javascript">          <span class="hljs-comment">// p元素的click事件没有向上冒泡，该函数不会被执行</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-literal">false</span></span><br><span class="language-javascript">      )</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="03-项目应用场景"><a href="#03-项目应用场景" class="headerlink" title="03 项目应用场景"></a>03 项目应用场景</h3><p><strong>场景：</strong></p><img src="https://s2.loli.net/2022/03/18/Dw9e2YEbGOsHrTB.png" alt="image-20220318184706337" style="zoom: 50%;" /><p>需求就是点击 <code>“ESC”</code> 关闭新建的那个框框，<code>event.stopImmediatePropagation()</code> 可以阻止事件冒泡，以及阻止其他的绑定事件的执行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React 长列表性能优化 -- react-window</title>
    <link href="/2022/03/28/React%20%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20--%20react-window/"/>
    <url>/2022/03/28/React%20%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20--%20react-window/</url>
    
    <content type="html"><![CDATA[<h2 id="React-长列表性能优化-–-react-window"><a href="#React-长列表性能优化-–-react-window" class="headerlink" title="React 长列表性能优化 – react-window"></a>React 长列表性能优化 – react-window</h2><blockquote><p>假如有一天，你遇到一个非常变态的需求或者一个不会分页的后端 – 前端拿到 1W+条数据时，你会怎么做？浏览器性能是有限的的，把 1w+条数据渲染到页面，非常容易造成页面卡顿，导致用户体验不佳。🤷‍♀️</p></blockquote><h3 id="01-常见的解决方案"><a href="#01-常见的解决方案" class="headerlink" title="01 常见的解决方案"></a>01 常见的解决方案</h3><p>1.懒加载</p><p>方式：通过监听列表的滚动，每当用户滚动到列表底部的时候，进行加载后面的数据追加渲染到 DOM 上。</p><p>缺点：当用户一直向下划，页面依然会产生大量 DOM 元素，占用内存过多，导致页面卡顿。</p><p>2.虚拟列表</p><p>方式：其核心思路，渲染长列表时，每次只渲染可视区域的列表数。</p><h3 id="02-虚拟列表技术"><a href="#02-虚拟列表技术" class="headerlink" title="02 虚拟列表技术"></a>02 虚拟列表技术</h3><blockquote><p>常见虚拟列表技术 react-window 和 react-virtualized ，有什么不同呢?</p></blockquote><p>这两个库都出自一个作者，<code>react-window</code> 是对 <code>react-virtualized</code> 的重写，至于为啥重写呢？作者给出的解释是，<code>react-virtualized</code> 考虑情况太多，增加了太多的非基本功能和组件。删除这些功能会导致之前使用的开发者痛苦面具 🤯，所以就重写了。</p><p><a href="https://github.com/bvaughn/react-window">react-window</a> 更加关注 <strong>smaller</strong>1 and <strong>faster</strong>。</p><h3 id="03-react-window-尝试"><a href="#03-react-window-尝试" class="headerlink" title="03 react-window 尝试"></a>03 react-window 尝试</h3><p>Here’s a <a href="https://codesandbox.io/s/bvaughn-react-window-fixed-size-list-vertical-forked-7xp7qn?file=/index.js:211-216">CodeSandbox</a></p><p>上面这块是比较基本的使用，我打算参考 <code>react-window</code> 的原理，去实现这个需求。</p><p><img src="https://s2.loli.net/2022/03/21/t48I7q9rUbwOYEK.png" alt="image-20220321182310892"></p><p>今天暂时还没研究透，明天实践下再进行补充。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useCallback 和 useMemo 的区别</title>
    <link href="/2022/03/28/useCallback%20%E5%92%8C%20useMemo%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2022/03/28/useCallback%20%E5%92%8C%20useMemo%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="useCallback-和-useMemo-的区别"><a href="#useCallback-和-useMemo-的区别" class="headerlink" title="useCallback 和 useMemo 的区别"></a>useCallback 和 useMemo 的区别</h2><blockquote><p>前言，刚看官方文档的时候。也许会觉得他们很像，或者认为<code>useCallback</code> 是 <code>useMemo</code>的语法糖 🍬</p><p>其实不然，他们虽然说都是 “性能优化” 的手段，他们的用法和关注层面还是有点不一样</p></blockquote><h3 id="01-useCallback"><a href="#01-useCallback" class="headerlink" title="01 useCallback"></a>01 useCallback</h3><p><strong>用法：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">doSomething</span>(a, b)<br>&#125;, [a, b])<br></code></pre></div></td></tr></table></figure><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p><p><strong>关注：</strong></p><p><code>useCallback</code> 一般用于函数更新，返回一个新的方法</p><h3 id="02-useMemo"><a href="#02-useMemo" class="headerlink" title="02 useMemo"></a>02 useMemo</h3><p><strong>用法：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b])<br></code></pre></div></td></tr></table></figure><p><strong>关注：</strong></p><p><code>useMemo</code> 一般用于组件中变量，返回变量值</p>]]></content>
    
    
    <categories>
      
      <category>hook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义 Hook 和 封装组件</title>
    <link href="/2022/03/28/%E8%87%AA%E5%AE%9A%E4%B9%89%20hooks%20%E5%92%8C%20%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/28/%E8%87%AA%E5%AE%9A%E4%B9%89%20hooks%20%E5%92%8C%20%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="自定义-Hook-和-封装组件"><a href="#自定义-Hook-和-封装组件" class="headerlink" title="自定义 Hook 和 封装组件"></a>自定义 Hook 和 封装组件</h2><blockquote><p>前言：</p><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p></blockquote><h3 id="01-自定义-Hook"><a href="#01-自定义-Hook" class="headerlink" title="01 自定义 Hook"></a>01 自定义 Hook</h3><blockquote><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。使得一些公共逻辑可以从项目中解耦出来，不仅项目其他地方中使用，还以提供给社区 💻。</p></blockquote><p>一般以 “<code>use</code>” 命名开头，这个是约束。也是为了让 React 帮我们更好地检查是否符合 <code>Hook</code> 规则。</p><p>一般放在项目的 <code>hooks</code> 文件下</p><p>✍️<strong>关于自定义 <code>Hook</code> 的封装：</strong></p><p>a.与项目逻辑解耦，抽离出公共逻辑</p><p>b.尽量不越界、不涉及到 UI，只关注逻辑</p><p>c.外部使用，做到只考虑 <code>输入</code> 和 <code>输出 </code>, 无关乎内部实现</p><p>推荐一个强大的 <strong>hooks 库 —</strong><a href="https://ahooks.js.org/"><strong>ahook</strong></a></p><h3 id="02-封装组件"><a href="#02-封装组件" class="headerlink" title="02 封装组件"></a>02 封装组件</h3><blockquote><p>封装组件，它和自定义 Hook，都用到函数组件，但是它更加关注 UI 层渲染。</p></blockquote><p>一般放在项目的 <code>components</code> 文件下</p><p>✍️<strong>关于<code>封装组件</code>：</strong></p><p>a. 更加关注 UI 层的渲染，注重考虑复用性</p><p>b.在设计组件时，多方面和多维度考虑，组件可扩展性</p><p>c.样式的丰富性，高度可再定制性</p>]]></content>
    
    
    <categories>
      
      <category>hook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应式布局小实践 --Rem 和媒体查询</title>
    <link href="/2022/03/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%8F%E5%AE%9E%E8%B7%B5%20--Rem%20%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/03/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%B0%8F%E5%AE%9E%E8%B7%B5%20--Rem%20%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="响应式布局小实践-–Rem-和媒体查询"><a href="#响应式布局小实践-–Rem-和媒体查询" class="headerlink" title="响应式布局小实践 –Rem 和媒体查询"></a>响应式布局小实践 –Rem 和媒体查询</h2><blockquote><p>前言：下午捣鼓了下，看了很多解决移动端自适应的方案，大多以 Rem 和媒体查询作为主流解决方案。另外 CSS3 的 flex 和 Grid 也是不戳的布局解决方案。</p></blockquote><h3 id="01-✔️Rem-媒体查询"><a href="#01-✔️Rem-媒体查询" class="headerlink" title="01 ✔️Rem / 媒体查询"></a>01 ✔️Rem / 媒体查询</h3><p>通俗一点说，<strong>Rem</strong> 是根据 <code>&lt;Html&gt;</code> 样式的 <code>font-size</code> 来计算相对大小的，比如说，<code>&lt;Html&gt;</code> 的 <code>font-size=16px</code>(默认)，那么就是相当于 <code>1rem=16px </code> 。当然<code>&lt;Html&gt;</code>的<code>font-size</code>是可以自行设置的。</p><p>**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries">媒体查询</a>**，具体可以看下官方文档，这边主要讲下它的常规使用。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 常见设备的媒体查询</span><br>@media screen and (max-<span class="hljs-attr">width</span>: 1160px)<br>@media screen and (max-<span class="hljs-attr">width</span>: 820px)ipad <span class="hljs-title class_">Air</span><br>@media screen and (max-<span class="hljs-attr">width</span>: 768px)ipad mini<br>@media screen and (max-<span class="hljs-attr">width</span>: 390px)iphone 12pro<br></code></pre></div></td></tr></table></figure><h3 id="02-✔️-实践"><a href="#02-✔️-实践" class="headerlink" title="02 ✔️ 实践"></a>02 ✔️ 实践</h3><p><strong>思路：</strong></p><ol><li><p>在响应式布局中，必须通过<code>js</code>来动态控制根元素<code>font-size</code>的大小。<code>( 用户设备宽度 / 设计稿标准宽度 ) * 100</code></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 这边封装成一个 hook</span><br><span class="hljs-keyword">import</span> &#123; useCallback, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMobileRem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inMobile = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> =<br>      (<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">1920</span>) * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;, [])<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, inMobile)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = inMobile<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, inMobile)<br>    &#125;<br>  &#125;, [inMobile])<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>通过<strong>媒体查询</strong>的方式，若当前设备宽度小于某个值时，采用<code>rem</code>单位的布局。</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 根据产品需求，去编写不同屏幕的样式</span><br>@media (min-<span class="hljs-attr">width</span>: 30em) and (max-<span class="hljs-attr">width</span>: 50em) &#123; ... &#125;<br></code></pre></div></td></tr></table></figure><h3 id="03-FAQ"><a href="#03-FAQ" class="headerlink" title="03 FAQ"></a>03 FAQ</h3><p>❓：px、rem 和 em 的区别？</p><p>💻：<strong>px</strong>是固定的像素，是相对于显示器屏幕分辨率而言的。<strong>em</strong>、<strong>rem</strong> 对于 <strong>px <strong>更具有灵活性，他们是相对长度单位，</strong>em</strong> 是相对于父元素的单位，<strong>rem</strong> (<strong>root em</strong> )是相对根元素的长度。</p>]]></content>
    
    
    <categories>
      
      <category>移动端兼容</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gird 网格布局</title>
    <link href="/2022/03/28/Gird%20%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <url>/2022/03/28/Gird%20%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Gird-网格布局"><a href="#Gird-网格布局" class="headerlink" title="Gird 网格布局"></a>Gird 网格布局</h2><blockquote><p>前言：昨天为了解决栅格布局，走了很多弯路。今天突然看到阮一峰老师<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">关于 Grid 的文章</a>让我发现了新大陆，U1S1 阮老师写的文章真的通俗易懂。努力向阮老师看齐，希望自己文章以后也可以被称赞！！话不多说，来干货！</p></blockquote><h3 id="01-网格布局"><a href="#01-网格布局" class="headerlink" title="01 网格布局"></a>01 网格布局</h3><p>之前的我一直都是用 <code>Flex</code> 弹性布局，觉得拥有 <code>Flex</code>, 这天下就没有我布不了的局。直到我发现了 <code>Grid</code>,是真的方便，难怪各各 UI 框架，都会看到一个叫做 <code>Grid</code> 布局。</p><p><strong>网格布局</strong>， 顾名思义是类似网格一样的布局（我好像说了一句废话）。为了什么这么说呢？<code>Gird</code> 是二维布局，它将容器用 “<strong>行</strong>” 和 “<strong>列</strong>”划分，而一个一个格子称作为单元格。前面说到 <code>Flex</code> 更像是一维布局。</p><h3 id="02-适用场景"><a href="#02-适用场景" class="headerlink" title="02 适用场景"></a>02 适用场景</h3><p><strong>语法方面</strong>，人家阮老师已经讲很详细了，这边偷个懒。讲两个常见的使用场景：</p><p>a. 假如做个商城列表，需要那种排排列列很整齐那种，还需要自适应两边的留白。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">180px</span>);<br>  <span class="hljs-attribute">justify-content</span>: space-evenly;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><img src="https://s2.loli.net/2022/03/25/ZB6RuVos9bn51wm.png" alt="image-20220325001113432" style="zoom:25%;" /><p>b. 一般网页页头，分成三部分，分别为 logo、中间区域（各个入口）、右侧区域（登录、输入框），一般这种都是两边固定，中间区域自适应。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/25/wsiYIxCnFlHtkqu.png" alt="image-20220325001325658"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>layout布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听说你还不会“虚拟列表”，对不起我来晚了</title>
    <link href="/2022/03/28/%E5%90%AC%E8%AF%B4%E4%BD%A0%E8%BF%98%E4%B8%8D%E4%BC%9A%E2%80%9C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E2%80%9D%EF%BC%8C%E5%AF%B9%E4%B8%8D%E8%B5%B7%E6%88%91%E6%9D%A5%E6%99%9A%E4%BA%86/"/>
    <url>/2022/03/28/%E5%90%AC%E8%AF%B4%E4%BD%A0%E8%BF%98%E4%B8%8D%E4%BC%9A%E2%80%9C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E2%80%9D%EF%BC%8C%E5%AF%B9%E4%B8%8D%E8%B5%B7%E6%88%91%E6%9D%A5%E6%99%9A%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h2 id="听说你还不会“虚拟列表”，对不起我来晚了"><a href="#听说你还不会“虚拟列表”，对不起我来晚了" class="headerlink" title="听说你还不会“虚拟列表”，对不起我来晚了"></a>听说你还不会“虚拟列表”，对不起我来晚了</h2><blockquote><p>前言：上次说到要实践 React- window , 今天终于可以过来还债辽😀！研究了许久，总共想到 3 种方法实现它。</p></blockquote><h3 id="01-什么是虚拟列表❓"><a href="#01-什么是虚拟列表❓" class="headerlink" title="01 什么是虚拟列表❓"></a>01 什么是虚拟列表❓</h3><p>它是当下解决长列表数据（2w数据量）高性能解决方案，它的原理也非常通俗易懂，正常情况下，2w数据或者更多数据要渲染到列表是非常耗时，且滚动起来非常卡的，总而言之用户体验非常差的。而<strong>虚拟列表</strong>，只需要渲染可视区域数据，它极大减少渲染性能的开销，提升了用户的体验。</p><p><img src="https://s2.loli.net/2022/03/30/a82CqZIzxPlos63.png" alt="image.png"></p><h3 id="02-实践起来💻"><a href="#02-实践起来💻" class="headerlink" title="02  实践起来💻"></a>02  实践起来💻</h3><blockquote><p>这边为了方便没有学过框架的小伙伴，我用原生的<code>Html</code>来编写，同时上传到了在线编辑IDE里面，可供大家参考</p></blockquote><p><strong>a.  Position 法：</strong></p><blockquote><ul><li><p>首先，我们需要定义几个变量</p><ul><li><p>startIndex:  用户可视区域的第一个数据项，参考上图就是 <code>item8</code> </p></li><li><p>endIndex: 用户可视区域的最后一个数据项，上图的 <code>item15</code></p></li><li></li></ul></li></ul></blockquote><p>我们只对可视层做渲染，但是为了保持整个容器像渲染正常长列表一样，里面的容器还需要保持原有的高度。这边把 <code>Html</code> 设计这样</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 外层容器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;vListContainer&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内层容器 --&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;phantomContent&quot;</span>&gt;</span><br>    ...<br>    <span class="hljs-comment">&lt;!-- item-1 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- item-2 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- item-3 --&gt;</span><br>    ....<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>其中，<code>vListContainer</code> 容器样式为<code>overflow-y: auto;</code>（出现滚动条）</p><ul><li><p><code>phantomContent</code> 容器样式为<code>position: relative</code> </p></li><li><p>内容器里面子项 <code>item-n</code> 样式为 <code>position: absolute</code></p></li><li><p>设计这样，就是为了方便通过<strong>相对定位</strong>的方式，把 <code>item-n</code> 渲染到可视区域去（灵魂👌）</p></li></ul></li><li><p>接下来，我们需要在 <code>vListContainer</code>  绑定 <strong>onScroll</strong> 函数，利用其 <strong>scrollTop</strong> 计算出 <code>startIndex</code> 和 <code>endIndex</code></p><p>计算之前，需要知道：</p><ul><li><strong>rowHeight</strong> ：单项数据的高度</li><li><strong>total</strong>： 总共数据量</li><li><strong>height</strong>：可视的高度，通过 <code>vListContainer</code> 的 <strong>clientHeight</strong> 可以拿到</li></ul></li><li><p>通过上述变量就可以计算出 ：</p><ul><li>列表总高度: <code>phantomHeight = total * rowHeight</code> 设置内层容器 <code>phantomContent </code>高度</li><li>可视范围内展示元素数：<code>limit = Math.ceil(height/rowHeight)</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onScroll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* 求得 startIndex，endtIndex  */</span><br>    <span class="hljs-keyword">const</span> &#123; scrollTop &#125; = vListContainer;<br>    <span class="hljs-keyword">const</span> currentStartIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(scrollTop / rowHeight);<br><br>    <span class="hljs-keyword">if</span> (currentStartIndex !== startIndex) &#123;<br>        startIndex = currentStartIndex;<br>        endtIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(currentStartIndex + limit, total);<br>    &#125;<br>    <span class="hljs-comment">// startIndex，endtIndex 更新后，渲染到可视区域</span><br>    <span class="hljs-title function_">renderDisplayContent</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>得到这些参数，我们就可以把数据项渲染到可视区域去辽😊</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDisplayContent</span>(<span class="hljs-params"></span>) &#123;<br>    phantomContent.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= endtIndex; i++) &#123;<br>        <span class="hljs-comment">// 遍历数据项，并渲染到 DOM 上</span><br>        <span class="hljs-keyword">var</span> x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;DIV&quot;</span>);<br>        x.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid #eee&quot;</span>;<br>        x.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;100%&quot;</span>;<br>        x.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&quot;absolute&quot;</span>;<br>        <span class="hljs-comment">// 这块关键代码，通过绝对定位，像钉子一样钉在可视区域</span><br>        x.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = i * rowHeight + <span class="hljs-string">&quot;px&quot;</span>;<br>        x.<span class="hljs-property">innerText</span> = i;<br>        phantomContent.<span class="hljs-title function_">appendChild</span>(x);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后就会得到一个简单高性能的列表 —&gt; 效果图💕 </p><p><img src="https://s2.loli.net/2022/03/30/abYPShq7o3wHLmG.gif" alt="高性能长列表效果图.gif"></p><blockquote><p><strong>结论：</strong>通过效果图，可以很清晰看到，<code>DOM</code>做到真正可渲染可视区的数据项，从 2w –&gt; 20 ,性能可谓是翻了很多倍呢😉。这边只是实现一个简单造轮子，建议大家一定要动手，能更快上手。另外 <code>React-window</code> 和 <code>react-virtualized</code> 是社区封装好的，当然，有现成是方便我们使用，但是一定动手，知识才是属于我们嘚！😎</p></blockquote><p><strong>线上Demo:</strong> <a href="https://codesandbox.io/s/new-snowflake-bo42ol?file=/index.html">new-snowflake-bo42ol - CodeSandbox</a></p><blockquote><p><strong>优化：</strong>现在渲染的是只是简单数据项，真正应用场景，可能有图片，各种文字，渲染起来可能会有卡顿。引入 <code>BufferSize</code>概念，类似缓冲区一样的。</p></blockquote><p><strong>优化后的Demo:</strong><a href="https://codesandbox.io/s/cocky-montalcini-762v0x?file=/index.html">cocky-montalcini-762v0x - CodeSandbox</a></p><blockquote><p>剩下两个方案，都和上面差不多，只是实现方式不一样。不做过多解释，举一反三。线上Demo 有标注关键代码部分</p></blockquote><p><strong>b. transform 法</strong></p><p><strong>关键思想：</strong> 利用 <code>transform</code> y属性，去造成那种划动的效果</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDisplayContent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//------ 关键代码部分 </span><br>    phantomContent.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate3d(0px,<span class="hljs-subst">$&#123;startIndex * rowHeight&#125;</span>px,0px)`</span><br>    <span class="hljs-comment">//------</span><br>    phantomContent.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = startIndex; i &lt;= endtIndex; i++ )&#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;DIV&quot;</span>);<br>        x.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid #eee&quot;</span><br>        x.<span class="hljs-property">innerText</span> = i<br>        phantomContent.<span class="hljs-title function_">appendChild</span>(x)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>线上Demo：</strong><a href="https://codesandbox.io/s/distracted-snowflake-v3400l?file=/index.html">distracted-snowflake-v3400l - CodeSandbox</a></p><p><strong>c. marginTop 和 marginBottom 法</strong></p><p><strong>关键思想：</strong> <strong>marginTop</strong> 和 <strong>marginBottom</strong> 去分别填充，可视区域的 <strong>上面</strong> 和 <strong>下面</strong>。（有兴趣可以试试 <strong>pandingTop</strong> 和 <strong>pandingBottom</strong>）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDisplayContent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//------关键代码部分</span><br>        phantomContent.<span class="hljs-property">style</span>.<span class="hljs-property">marginTop</span> = rowHeight * startIndex + <span class="hljs-string">&quot;px&quot;</span>;<br>    <span class="hljs-comment">//------</span><br>        phantomContent.<span class="hljs-property">style</span>.<span class="hljs-property">marginBottom</span> =<br>          rowHeight * (total - endtIndex) + <span class="hljs-string">&quot;px&quot;</span>;<br>        phantomContent.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= endtIndex; i++) &#123;<br>          <span class="hljs-keyword">var</span> x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;DIV&quot;</span>);<br>          x.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid #eee&quot;</span>;<br>          x.<span class="hljs-property">innerText</span> = i;<br>          phantomContent.<span class="hljs-title function_">appendChild</span>(x);<br>        &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure><p><strong>线上Demo :</strong> <a href="https://codesandbox.io/s/hardcore-newton-phulu8?file=/index.html">hardcore-newton-phulu8 - CodeSandbox</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useThrottle hook节流</title>
    <link href="/2022/03/28/useThrottle%20hook%20%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <url>/2022/03/28/useThrottle%20hook%20%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="useThrottle-hook-节流"><a href="#useThrottle-hook-节流" class="headerlink" title="useThrottle hook 节流"></a>useThrottle hook 节流</h2><blockquote><p>前言, 节流是前端常用工具函数。比如说进行窗口的 resize, onscroll 等操作时，事件调用的频率很高，使得浏览器开销很大，使得用户的体验很差。使用节流可以极大降低调用的频率，所以将其封装成 hook。</p></blockquote><p><strong>节流的原理：</strong> 定义一个计时器，规定在 delay 后执行函数。如果在 delay 时间内再次触发，则会判断定时器是否存在，有则返回（不执行操作）；无则，重新设定一个计时器（delay 后执行函数）。</p><p><strong>节流 hook:</strong></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useEffect, useCallback, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useThrottle</span>(<span class="hljs-params">fn, delay, dep = []</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; current &#125; = <span class="hljs-title function_">useRef</span>(&#123; fn, <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span> &#125;)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    current.<span class="hljs-property">fn</span> = fn<br>  &#125;, [fn, current])<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useCallback</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">...args</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!current.<span class="hljs-property">timer</span>) &#123;<br>        current.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">delete</span> current.<span class="hljs-property">timer</span><br>        &#125;, delay)<br>        current.<span class="hljs-property">fn</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args)<br>      &#125;<br>    &#125;,<br>    [...dep, delay, current]<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useThrottle<br></code></pre></div></td></tr></table></figure><p><strong>使用方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @fn: 函数</span><br><span class="hljs-comment"> * @delay: 延迟时间（ms）</span><br><span class="hljs-comment"> * @dep: 依赖</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">useThrottle</span>(func, <span class="hljs-number">500</span>, [])<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React of Study</title>
    <link href="/2022/03/18/React%20of%20Study/"/>
    <url>/2022/03/18/React%20of%20Study/</url>
    
    <content type="html"><![CDATA[<h1 id="React-of-Study"><a href="#React-of-Study" class="headerlink" title="React of Study"></a>React of Study</h1><h2 id="一-React-入门"><a href="#一-React-入门" class="headerlink" title="一.React 入门"></a>一.React 入门</h2><h3 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h3><p>JSX，是一个 JavaScript 的语法扩展。</p><h5 id="语法规则："><a href="#语法规则：" class="headerlink" title="语法规则："></a>语法规则：</h5><ul><li><p>在 JSX 中嵌入表达式(区分表达式与代码块)</p></li><li><p>本身 JSX 也是一个表达式</p></li><li><p>虚拟 DOM ,一些标签的属性采用 <strong>“ 小驼峰法”</strong></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">fontSize:</span> &#x27;<span class="hljs-attr">26px</span>&#x27; &#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure></li><li><p>JSX 里的 <code>class</code> 变成了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className"><code>className</code></a>，而 <code>tabindex</code> 则变为 tabIndex;</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure></li><li><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220110162421373.png" alt="image-20220110162421373">。</p></li></ul><h3 id="React-Developer-Tools-调试工具"><a href="#React-Developer-Tools-调试工具" class="headerlink" title="React Developer Tools 调试工具"></a>React Developer Tools 调试工具</h3><ul><li>Components 组件结构</li><li>Profiler 性能监控</li></ul><h2 id="二-React-面向组件编程"><a href="#二-React-面向组件编程" class="headerlink" title="二.React 面向组件编程"></a>二.React 面向组件编程</h2><h3 id="1-基本理解和使用"><a href="#1-基本理解和使用" class="headerlink" title="1.基本理解和使用"></a>1.基本理解和使用</h3><ul><li><p>函数式组件</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 在 Babel 下 ，是严格模式</span><br><span class="hljs-comment">// 函数式编程</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是函数式编程“简单组件”<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br><span class="hljs-comment">// &lt;MyComponent/&gt; react 帮你调用 MyComponent</span><br></code></pre></div></td></tr></table></figure></li><li><p>类式组件</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 在 Babel 下 ，是严格模式</span><br><span class="hljs-comment">// 类式编程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-comment">// “复杂组件” 有 State</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是类式编程“复杂组件”<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br><span class="hljs-comment">// &lt;MyComponent/&gt; react 帮你 new MyComponent</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="2-组件实例的三大核心属性-1-State"><a href="#2-组件实例的三大核心属性-1-State" class="headerlink" title="2.组件实例的三大核心属性 1: State"></a>2.组件实例的三大核心属性 1: State</h3><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>1.state 是组件的状态机，通过更新组件的 state 来更新对应页面显示（重新渲染）</p><p>2.state 是对象形式的，多个 key-value 组合</p><h5 id="值得注意："><a href="#值得注意：" class="headerlink" title="值得注意："></a>值得注意：</h5><blockquote><p>1.组件中 render 方法中的 this 是组件实例的对象</p><p>2.组件自定义方法中，默认开启了 use strict，为 undefine,解决：</p><ul><li><p>bind()，强制绑定实例对象的 this</p></li><li><p>箭头函数</p><p>3.setState()，组件的数据不可以直接更改。</p></li></ul></blockquote><p>​</p><h3 id="3-组件实例的三大核心属性-2-props"><a href="#3-组件实例的三大核心属性-2-props" class="headerlink" title="3.组件实例的三大核心属性 2: props"></a>3.组件实例的三大核心属性 2: props</h3><h5 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h5><ol><li>每个组件对象都会有 props 属性</li><li>组件标签的所有属性都保存在 props 中</li><li>用 props-type.js 对属性进行类型检测，必要性判断(React161 开始)</li></ol><h5 id="值得注意：-1"><a href="#值得注意：-1" class="headerlink" title="值得注意："></a>值得注意：</h5><blockquote><ul><li>组件内部的 props 是只读属性的</li><li>有组件外向组件内传递变化的数据</li></ul></blockquote><h3 id="4-组件实例的三大核心属性-3-refs-与事件处理"><a href="#4-组件实例的三大核心属性-3-refs-与事件处理" class="headerlink" title="4.组件实例的三大核心属性 3: refs 与事件处理"></a>4.组件实例的三大核心属性 3: refs 与事件处理</h3><h5 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h5><blockquote><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p></blockquote><h5 id="三种形式创建-ref"><a href="#三种形式创建-ref" class="headerlink" title="三种形式创建 ref:"></a>三种形式创建 ref:</h5><ol><li><p>字符串形式的 ref</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">input ref=<span class="hljs-string">&quot;input1&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>回调形式的 ref</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">input ref=&#123;<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = a&#125; type=<span class="hljs-string">&quot;text&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>createRef 创建 ref 容器</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">input2 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>input ref=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span>&#125; type=<span class="hljs-string">&quot;text&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><h5 id="事件处理："><a href="#事件处理：" class="headerlink" title="事件处理："></a>事件处理：</h5><ol><li>通过 onXxx 属性指定事件处理函数（注意大小写）<ul><li>React 使用的式自定义(合成)事件，而不是原生的 DOM 事件–更好兼容性</li><li>React 中的事件通过委托方式处理的（委托给组件最外层的元素）–更高的效率</li></ul></li><li>通过 event.target 得到发生事件的 DOM 对象</li></ol><h3 id="5-组件的生命周期："><a href="#5-组件的生命周期：" class="headerlink" title="5.组件的生命周期："></a>5.组件的生命周期：</h3><h5 id="旧版本的生命周期："><a href="#旧版本的生命周期：" class="headerlink" title="旧版本的生命周期："></a>旧版本的生命周期：</h5><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220112113749152.png" alt="image-20220112113749152"></p><h6 id="生命周期的三个阶段（旧）："><a href="#生命周期的三个阶段（旧）：" class="headerlink" title="生命周期的三个阶段（旧）："></a>生命周期的三个阶段（旧）：</h6><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220112114024249.png" alt="image-20220112114024249"></p><h5 id="新版本生命周期（-gt-v17-0-0）："><a href="#新版本生命周期（-gt-v17-0-0）：" class="headerlink" title="新版本生命周期（&gt;v17.0.0）："></a>新版本生命周期（&gt;v17.0.0）：</h5><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220112140120136.png" alt="image-20220112140120136"></p><h6 id="新增生命钩子（2-个）："><a href="#新增生命钩子（2-个）：" class="headerlink" title="新增生命钩子（2 个）："></a>新增生命钩子（2 个）：</h6><blockquote><p>getDerivedStateFromProps：此方法适用于<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state">罕见的用例</a>，即 state 的值在任何时候都取决于 props。</p><p>getSnapshotBeforeUpdate()：它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p></blockquote><h6 id="即将废弃生命钩子（三个）：均需在前面加上-UNSAFE-前缀"><a href="#即将废弃生命钩子（三个）：均需在前面加上-UNSAFE-前缀" class="headerlink" title="即将废弃生命钩子（三个）：均需在前面加上 UNSAFE_ (前缀)"></a>即将废弃生命钩子（三个）：均需在前面加上 UNSAFE_ (前缀)</h6><ul><li>componentWillMount（）</li><li>componentWillUpdate（）</li><li>componentWillReceiveProps（）</li></ul><h3 id="6-虚拟-DOM，diff-算法："><a href="#6-虚拟-DOM，diff-算法：" class="headerlink" title="6.虚拟 DOM，diff 算法："></a>6.虚拟 DOM，diff 算法：</h3><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220112161357938.png" alt="image-20220112161357938"></p><h2 id="三-React-ajax"><a href="#三-React-ajax" class="headerlink" title="三.React ajax"></a>三.React ajax</h2><h3 id="1-react-脚手架配置代理总结"><a href="#1-react-脚手架配置代理总结" class="headerlink" title="1.react 脚手架配置代理总结"></a>1.react 脚手架配置代理总结</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220113230205483.png" alt="image-20220113230205483"></p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><blockquote><p>注意从 http-proxy-middleware v2.0 开始使用 createProxyMiddleware 代替 proxy</p><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220113230149722.png" alt="image-20220113230149722"></p></blockquote><h3 id="2-xhr（axios）-和-fetch-的区别"><a href="#2-xhr（axios）-和-fetch-的区别" class="headerlink" title="2.xhr（axios） 和 fetch 的区别"></a>2.xhr（axios） 和 fetch 的区别</h3><blockquote><p><strong>xhr 与 fetch 是同一级别的 ！！！</strong></p></blockquote><h5 id="1-传统的-xhr-请求"><a href="#1-传统的-xhr-请求" class="headerlink" title="1.传统的 xhr 请求"></a>1.传统的 xhr 请求</h5><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url)<br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;json&#x27;</span><br><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">response</span>)<br>&#125;<br><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Oops, error&#x27;</span>)<br>&#125;<br><br>xhr.<span class="hljs-title function_">send</span>()<br></code></pre></div></td></tr></table></figure><h5 id="2-未优化的-fetch-请求"><a href="#2-未优化的-fetch-请求" class="headerlink" title="2.未优化的 fetch 请求"></a>2.未优化的 fetch 请求</h5><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(url)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Oops, error&#x27;</span>)<br>  &#125;)<br></code></pre></div></td></tr></table></figure><h5 id="3-优化后的-fetch-请求"><a href="#3-优化后的-fetch-请求" class="headerlink" title="3.优化后的 fetch 请求"></a>3.优化后的 fetch 请求</h5><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url)<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Oops, error&#x27;</span>, e)<br>&#125;<br><span class="hljs-comment">// 注：这段代码如果想运行，外面需要包一个 async function</span><br></code></pre></div></td></tr></table></figure><h3 id="3-PubSubJs-消息订阅-与-发布机制"><a href="#3-PubSubJs-消息订阅-与-发布机制" class="headerlink" title="3.PubSubJs 消息订阅 与 发布机制"></a>3.PubSubJs 消息订阅 与 发布机制</h3><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220114154029332.png" alt="image-20220114154029332"></p><h5 id="使用过程："><a href="#使用过程：" class="headerlink" title="使用过程："></a>使用过程：</h5><p>导入 pubsub.js 模块</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PubSub</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span><br></code></pre></div></td></tr></table></figure><p>在需要 消息订阅 的组件，订阅</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> token = <span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;MY TOPIC&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg, data</span>) =&gt;</span> &#123;&#125;)<br></code></pre></div></td></tr></table></figure><p>在需要 发布 组件中，发布消息（msg:消息，data:数据）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;MY TOPIC&#x27;</span>, <span class="hljs-string">&#x27;hello world!&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>消息订阅的组件待销毁后，取消订阅</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">unsubscribe</span>(token)<br></code></pre></div></td></tr></table></figure><h2 id="四-React-路由"><a href="#四-React-路由" class="headerlink" title="四.React 路由"></a>四.React 路由</h2><h3 id="1-Spa-理解"><a href="#1-Spa-理解" class="headerlink" title="1.Spa 理解"></a>1.Spa 理解</h3><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220114155209771.png" alt="image-20220114155209771"></p><h3 id="2-路由的理解"><a href="#2-路由的理解" class="headerlink" title="2.路由的理解"></a>2.路由的理解</h3><ol><li><p>什么是路由？</p><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220114155416804.png" alt="image-20220114155416804"></p></li><li><p>路由分类</p><ul><li><p>后端路由</p><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220114160524889.png" alt="image-20220114160524889"></p></li><li><p>前端路由</p><p>方式一：H5 推出来的 history 模式(旧的浏览器不兼容)</p><p>方式二：hash 值（锚点）</p><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220114160544635.png" alt="image-20220114160544635"></p></li></ul></li></ol><h3 id="3-路由基本使用："><a href="#3-路由基本使用：" class="headerlink" title="3.路由基本使用："></a>3.路由基本使用：</h3><h2 id="五-Redux-状态管理"><a href="#五-Redux-状态管理" class="headerlink" title="五.Redux 状态管理"></a>五.Redux 状态管理</h2><h3 id="1-redux-原理图"><a href="#1-redux-原理图" class="headerlink" title="1.redux 原理图"></a>1.redux 原理图</h3><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220126180325926.png" alt="image-20220126180325926"></p><h2 id="2-react-redux-原理图"><a href="#2-react-redux-原理图" class="headerlink" title="2.react-redux 原理图"></a>2.react-redux 原理图</h2><p><img src="C:\Users\DuoRouSai\AppData\Roaming\Typora\typora-user-images\image-20220126180413848.png" alt="image-20220126180413848"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化--批量导入模块</title>
    <link href="/2022/03/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96--%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/03/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96--%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前端工程化–批量导入模块"><a href="#前端工程化–批量导入模块" class="headerlink" title="前端工程化–批量导入模块"></a>前端工程化–批量导入模块</h2><h3 id="01-起因"><a href="#01-起因" class="headerlink" title="01 起因"></a>01 起因</h3><blockquote><p>前端项目中，可能随着项目的庞大的，模块随之项目体量而变多，比如说 service 模块下有 100+ 模块，手动引入实在浪费时间了，所以程序猿能用技术偷懒，就不要手工。</p></blockquote><h3 id="02-具体实现"><a href="#02-具体实现" class="headerlink" title="02 具体实现"></a>02 具体实现</h3><blockquote><p><a href="https://webpack.docschina.org/guides/dependency-management/#requirecontext">官方文档在这里~~~</a></p></blockquote><p>这边具体语法可以参考官方文档，下边具体是具体实现：</p><p>比如：</p><p><code>service</code> 模块下有个<code>modules</code>，存放 <code>a.js, b.js, c.js</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// service/index.js</span><br><span class="hljs-comment">// 前端工程化里面常用的批量导入文件</span><br><span class="hljs-keyword">const</span> requireContext = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&#x27;./modules&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.js$/</span>)<br><span class="hljs-comment">// 用于存放模块的数组</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MODULES</span> = []<br><span class="hljs-keyword">const</span> requireContextKeys = requireContext.<span class="hljs-title function_">keys</span>()<br><br><span class="hljs-comment">// 根据上面批量导入的文件读取里面定义的模块到 MOUDULES 数组中</span><br>requireContextKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = requireContext(item)<br>  <span class="hljs-variable constant_">MODULES</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">Service</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>通过 <code>clog</code> 打印 <code>MODULES</code> 数组</p><p><img src="https://i.ibb.co/YZz7vXL/image-20220314121929909.png"></p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端工程化</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 事件循环</title>
    <link href="/2022/03/18/JavaScript%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/03/18/JavaScript%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-事件循环"><a href="#JavaScript-事件循环" class="headerlink" title="JavaScript 事件循环"></a>JavaScript 事件循环</h2><p>唠唠基础😊</p><p>众所周知 <code>js</code> 是单线程的，至于为什么是单线程的？</p><p>答： <code>js</code>作为脚本语言，其主要负责 <code>操作DOM</code> 和 <code>用户交互</code> 。假如变成多线程的话，一个线程在给某个<code>DOM</code> 添加内容 ，而另外一个线程正在删除这个 <code>DOM</code> 一切就乱套了。</p><h3 id="01-同步任务和异步任务"><a href="#01-同步任务和异步任务" class="headerlink" title="01 同步任务和异步任务"></a>01 同步任务和异步任务</h3><p>​        <strong>虽然 <code>js</code> 是单线程，但是引入两个概念，一个是<code>同步</code>，另外一个<code>异步</code>。</strong></p><ul><li>同步任务：</li></ul><p>代码是按照<code>执行栈</code>顺序执行下来的，比如：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DouR&quot;</span>)<br><span class="hljs-comment">// console:</span><br><span class="hljs-comment">// 1：Hello </span><br><span class="hljs-comment">// 2：DouR</span><br></code></pre></div></td></tr></table></figure><ul><li>异步任务：</li></ul><p>异步操作，比如：<code>setTimeout</code>，<code>Promise</code>，<code>Ajax</code>…等。当顺序执行 <code>执行栈</code> 代码时，遇到异步操作，可以把它们看做比较耗时的工作，放入<code>任务队列</code>中去，接着执行代码，等执行完同步代码后在执行<code>任务队列</code> 的任务。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DouR&quot;</span>)<br><span class="hljs-comment">// console:</span><br><span class="hljs-comment">// 1: DouR</span><br><span class="hljs-comment">// 2: Hello </span><br></code></pre></div></td></tr></table></figure><p>可以很清晰看到先打印 <code>DouR</code> </p><h3 id="02-Event-Loop"><a href="#02-Event-Loop" class="headerlink" title="02 Event Loop"></a>02 Event Loop</h3><p>事件循环就是 <code>入栈出栈</code> 的过程，上面提到的异步任务，可以分成 <code>宏任务（Macrotask）</code>  和  <code>微任务（Microtask）</code></p><p><strong>宏任务：</strong>setTimeout, setInterval, setImmediate, I/O, UI render</p><p><strong>微任务：</strong>process.nextTick, Promises, Object.observe, MutationObserver(H5 新特性)</p><p><strong>每一次 Event Loop 触发时：</strong></p><ol><li>首先执行<code>主执行栈</code>任务，例如 script 任务</li><li>分别将 <code>宏任务</code> 和 <code>微任务</code> ,压入<code>宏任务队列</code> 和 <code>微任务队列</code></li><li>接着，先取出 <code>微任务队列</code> 执行直至清空（执行过程中，碰到<code>微任务</code>或者<code>宏任务</code> 分别压入队列中去，用于下一轮 Event loop执行）</li><li>—— 新的一轮 Event Loop——</li><li>取出 <code>宏任务队列</code> 执行直至清空 </li><li>取出 <code>微任务队列</code> 执行直至清空 </li><li>5、6重复</li></ol><p><strong>试试这个栗子：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;global&#x27;</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">5</span>;i ++) &#123;<br>  setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i)<br>  &#125;,i*<span class="hljs-number">1000</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i)<br>&#125;<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br> &#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;then1&#x27;</span>)<br>&#125;)<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timeout2&#x27;</span>)<br>  <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timeout2_promise&#x27;</span>)<br>    resolve()<br>  &#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timeout2_then&#x27;</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></div></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://i.ibb.co/9YbnGCm/image-20220308213843024.png" alt="image-20220308213843024"></p><p><strong>说个冷知识，浏览器的事件循环 和 Node事件循环不一致</strong><a href="https://juejin.cn/post/6844903574560833550">浏览器和Node不同的事件循环（Event Loop） - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style-Components  浅体验</title>
    <link href="/2022/03/07/Style-Component%20%20%E6%B5%85%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/03/07/Style-Component%20%20%E6%B5%85%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="Style-Components-浅体验"><a href="#Style-Components-浅体验" class="headerlink" title="Style-Components  浅体验"></a>Style-Components  浅体验</h2><p><img src="https://styled-components.com/icon.png"></p><blockquote><p>当你还在烦恼你的 <code>css</code> 为啥总是会影响到其他的组件，可以考虑下 <code>style-component</code> 了！官方 icon 就很魔性</p></blockquote><h3 id="01-安装"><a href="#01-安装" class="headerlink" title="01 安装"></a>01 安装</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install --save styled-components<br></code></pre></div></td></tr></table></figure><h3 id="02-简单使用下"><a href="#02-简单使用下" class="headerlink" title="02 简单使用下"></a>02 简单使用下</h3><p>首先创建一个 <code>style.js</code> 来编写 <code>css</code>, 对！你没有听错，<code>css</code> 写在 <code>js</code> 中。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// style.js</span><br><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloDiv</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><br><span class="hljs-string">    width: 200px;</span><br><span class="hljs-string">    text-align: center;</span><br><span class="hljs-string">    background-color: orange;</span><br><span class="hljs-string">    color: yellow;</span><br><span class="hljs-string">    .box &#123;</span><br><span class="hljs-string">        color: blue;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span><br></code></pre></div></td></tr></table></figure><p>再然后，把 <code>style.js</code> 引入到 <code>Hello.jsx</code> ，使用 <code>HelloDiv</code> 作为标签名，就会得到一个语义化的自定义标签。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// Hello.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HelloDiv</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span> () &#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloDiv</span>&gt;</span></span><br><span class="language-xml">             Hello style-components</span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">                 我是 box</span><br><span class="language-xml">             <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">HelloDiv</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，咱们打开控制台瞧瞧，给咱 <code> Hello组件</code> 起了啥标签名</p><p><img src="https://i.ibb.co/BGLrtbd/image-20220302113342382.png"></p><p>神奇不，再也不用担心，写的样式影响到其他的组件啦…</p><h3 id="03-扩展：ThemeProvider"><a href="#03-扩展：ThemeProvider" class="headerlink" title="03 扩展：ThemeProvider"></a>03 扩展：ThemeProvider</h3><blockquote><p>假如你项目当下或者未来有定制化 <code>theme</code> 的需求，快来看这，来对地啦！</p></blockquote><p><strong>使用方式：</strong></p><p>首先你需要定义一个存放定义各种各样的主题样式 <code>theme.js</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// theme.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">c_blue</span>: <span class="hljs-string">&quot;#3B81F7&quot;</span>, *<span class="hljs-comment">// 蓝色*</span><br>  <span class="hljs-attr">c_yellow</span>: <span class="hljs-string">&quot;#FFA800&quot;</span>, *<span class="hljs-comment">// 黄色*</span><br>  <span class="hljs-attr">c_red</span>: <span class="hljs-string">&quot;#FF2121&quot;</span>, *<span class="hljs-comment">// 红色*</span><br>  <span class="hljs-attr">c_green</span>: <span class="hljs-string">&quot;#07C160&quot;</span>, *<span class="hljs-comment">// 绿色*</span><br>  <span class="hljs-attr">c_white</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>, *<span class="hljs-comment">// 白色*</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，在你项目最最最..最根标签下，使用  <code>styled-components</code> 提供的 ThemeProvider 标签包裹起来，再把你定义好的 <code>theme</code> 的作为 <code>props</code> 引入进去</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// src/index.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ThemeProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><br><span class="hljs-keyword">import</span> theme <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./theme&quot;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span>  <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">theme</span> &#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br></code></pre></div></td></tr></table></figure><p>接下来，你就愉快地使用你在 <code>theme.js</code>  定义的颜色</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// Hello/style.js</span><br><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloDiv</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><br><span class="hljs-string">    width: 200px;</span><br><span class="hljs-string">    text-align: center;</span><br><span class="hljs-string">    background-color: <span class="hljs-subst">$&#123;p =&gt; p.theme.c_orange&#125;</span>;</span><br><span class="hljs-string">    color: <span class="hljs-subst">$&#123;p =&gt; p.theme.c_yellow&#125;</span> ;</span><br><span class="hljs-string">    .box &#123;</span><br><span class="hljs-string">        color:<span class="hljs-subst">$&#123;p =&gt; p.theme.c_blue&#125;</span> ;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span><br></code></pre></div></td></tr></table></figure><h3 id="04扩展：createGlobalStyle"><a href="#04扩展：createGlobalStyle" class="headerlink" title="04扩展：createGlobalStyle"></a>04扩展：createGlobalStyle</h3><blockquote><p>用于覆盖全局样式，比如想修改UI 框架默认的样式…</p></blockquote><p><strong>使用方式：</strong></p><p>这边以修改 <code>antd</code> 的 <code>&lt;Button /&gt;</code> 组件为例 </p><p><img src="https://i.ibb.co/0Ck5WF8/image-20220307170932506.png" alt="image-20220307170932506"></p><p>首先，使用 <code>style-components</code> 的 <code>createGlobalStyle</code> API 创建一个需要覆盖的样式</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// style.js</span><br><span class="hljs-keyword">import</span> &#123;createGlobalStyle&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledIndex</span> = createGlobalStyle<span class="hljs-string">`</span><br><span class="hljs-string">    .ant-btn-primary &#123;</span><br><span class="hljs-string">        background-color: orange;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span><br></code></pre></div></td></tr></table></figure><p>接着，引用需要的覆盖的样式的组件中去</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StyledIndex</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">StyledIndex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">StyledIndex</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>),<br>);<br></code></pre></div></td></tr></table></figure><p>当组件被 render 的时候，读到 <code>StyledIndex</code> 就会被注入全局样式中去，变成下面这样…</p><p><img src="https://i.ibb.co/DLJr0vK/image-20220307170743466.png" alt="image-20220307170743466"></p><p><strong>还有一种情况，就是你只是想单独定制，但不影响到其他组件的样式，可以这样做：</strong></p><p>定义 <code>MyButton组件</code></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// MyButton.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StyledIndex</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span> (props) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">StyledIndex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">StyledIndex</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">mybtu</span> $&#123;<span class="hljs-attr">props.className</span> || &#x27;&#x27;&#125;`&#125;&gt;</span>MyButton<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// style.js</span><br><span class="hljs-keyword">import</span> &#123;createGlobalStyle&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledIndex</span> = createGlobalStyle<span class="hljs-string">`</span><br><span class="hljs-string">// 用 mybtu 类名包裹起来</span><br><span class="hljs-string">    .mybtu &#123;</span><br><span class="hljs-string">      &amp;.ant-btn-primary &#123;</span><br><span class="hljs-string">          background-color: orange;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span><br></code></pre></div></td></tr></table></figure><p>然后引入到 <code>index.js</code> 就会得到：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./MyButton.jsx&quot;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>),<br>);<br></code></pre></div></td></tr></table></figure><p><img src="https://i.ibb.co/16Y1019/image-20220307171756082.png" alt="image-20220307171756082"></p><h3 id="05-后面的学习到在继续更新"><a href="#05-后面的学习到在继续更新" class="headerlink" title="05 后面的学习到在继续更新"></a>05 后面的学习到在继续更新</h3><p>🌊翻滚吧后浪…</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>Style-Components</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hook 初体验</title>
    <link href="/2022/03/02/React%20Hook%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/03/02/React%20Hook%20%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Hook-初体验"><a href="#React-Hook-初体验" class="headerlink" title="React Hook 初体验"></a>React Hook 初体验</h1><h2 id="1-Hook-简介"><a href="#1-Hook-简介" class="headerlink" title="1.Hook 简介"></a>1.Hook 简介</h2><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。</p><h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2.动机"></a>2.动机</h2><p><a href="https://react.docschina.org/docs/hooks-intro.html#motivation">官方解释：</a></p><ol><li>组件之间复用状态逻辑很难</li><li>复杂组件变得难以理解</li><li>难以理解的 class</li></ol><h2 id="3-Hook-规则"><a href="#3-Hook-规则" class="headerlink" title="3.Hook 规则"></a>3.Hook 规则</h2><h4 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h4><blockquote><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。</p></blockquote><h4 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h4><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><h2 id="4-基础-Hook"><a href="#4-基础-Hook" class="headerlink" title="4.基础 Hook"></a>4.基础 Hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>function 组件示例：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>等价的 Class 示例：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="language-xml">          Click me</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote><p><em>Effect Hook</em> 可以让你在函数组件中执行副作用操作</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">// Similar to componentDidMount and componentDidUpdate:</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// Update the document title using the browser API</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>提示</p><p>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p></blockquote><h4 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h4><p>使用 class 的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 实时更新标签页 title</span><br><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>&#125;<br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当你使用 hook：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 当组件重新渲染之后就会执行</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h4><p>使用 class 的示例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。例如：订阅-发布</span><br><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>     );<br> &#125;<br><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当你使用 hook：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// effect 中返回一个函数，这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>)<br>  <span class="hljs-comment">// 清除订阅</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="5-额外的-Hook"><a href="#5-额外的-Hook" class="headerlink" title="5.额外的 Hook"></a>5.额外的 Hook</h2><h2 id="6-自定义-Hook"><a href="#6-自定义-Hook" class="headerlink" title="6.自定义 Hook"></a>6.自定义 Hook</h2>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React-Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npx 切换不同版本的 node 😲</title>
    <link href="/2022/02/25/npx%20%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%20node%20%F0%9F%98%B2/"/>
    <url>/2022/02/25/npx%20%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%20node%20%F0%9F%98%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="npx-切换不同版本的-node-😲"><a href="#npx-切换不同版本的-node-😲" class="headerlink" title="npx 切换不同版本的 node 😲"></a>npx 切换不同版本的 node 😲</h2><p>偶然发现 <code>node</code> 的 <code>npx</code> 可以切换不同版本的 <code>node</code>,妥妥的 node 版本管理工具。之前也试过 <code>nvm</code> ，在某些场景下，个人感觉 <code>npx</code> 更方便点。</p><h3 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h3><blockquote><p>利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 <a href="https://www.npmjs.com/package/node">node 模块</a>。</p></blockquote><p>具体的 <code>npx</code> 语法，可以参考阮一峰老师，[此处](<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">npx 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a>)</p><h3 id="02-示例"><a href="#02-示例" class="headerlink" title="02 示例"></a>02 示例</h3><p>模拟一个需要 <code>node@12.xx.xx</code> 才能启动的项目</p><p>使用 npx 下载对应 node 版本模块</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npx node@12.9.1 -v<br>v12.9.1<br></code></pre></div></td></tr></table></figure><p>找到需要启动项目的目录下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npx -p node@12.9.1 npm start<br></code></pre></div></td></tr></table></figure><p>项目启动成功…</p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npx</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 那些事儿</title>
    <link href="/2022/02/21/TypeScript%20%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <url>/2022/02/21/TypeScript%20%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="TypeScript-那些事儿"><a href="#TypeScript-那些事儿" class="headerlink" title="TypeScript 那些事儿"></a>TypeScript 那些事儿</h2><h3 id="01-变量类型-😊"><a href="#01-变量类型-😊" class="headerlink" title="01 变量类型 😊"></a>01 变量类型 😊</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 变量名 : 变量类型 = value<br><span class="hljs-keyword">function</span> (<span class="hljs-params"> 变量名：变量类型 </span>): 变量类型&#123;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><table><thead><tr><th>类型</th><th>例子</th><th align="center">描述</th></tr></thead><tbody><tr><td>number</td><td>1,22,2.5</td><td align="center">任意数字</td></tr><tr><td>string</td><td>‘DuoR’,”bbb”</td><td align="center">任意字符串</td></tr><tr><td>boolean</td><td>true,false</td><td align="center"></td></tr><tr><td>字面量</td><td>其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td>any</td><td>*</td><td align="center">任意类型</td></tr><tr><td>unknown</td><td>*</td><td align="center">类型安全的 any</td></tr><tr><td>void</td><td>空值 undefined</td><td align="center">没有值</td></tr><tr><td>never</td><td>没有值</td><td align="center">不能是任何值</td></tr><tr><td>object</td><td>对象值</td><td align="center">js Object</td></tr><tr><td>array</td><td>[1,2,3,]</td><td align="center">js array</td></tr><tr><td>tuple</td><td>[4,5]</td><td align="center">元组，表示一个已知元素数量和类型的数组</td></tr><tr><td>enum</td><td>enum{A,B}</td><td align="center">枚举</td></tr><tr><td>联合声明</td><td>boolean | string</td><td align="center">可以是 boolean 和 string 类型</td></tr></tbody></table><ul><li><p>变量类型之间是不可以互相赋值的，否则会报错</p></li><li><p>声明和赋值是同时进行的，TS 可以自动对类型进行检测,可以省略定义类型的步骤</p></li><li><p>类型断言，<code>变量1 = &lt;变量类型&gt; 变量名2 或 变量1 = 变量名2 as 变量类型</code></p></li><li><p>类型的别名, <code>type 自定义类型名 = 变量类型（|，&amp;）</code></p></li><li><p>typescrpt 3.4 引入 readonly, 修饰后，变量只读:</p></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: readonly string[]= [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>]<br></code></pre></div></td></tr></table></figure><p><strong>注意点：</strong></p><p>a. 在 <code>tsconfig.json</code> 指定了<code>&quot;strictNullChecks&quot;:false</code>，<code>undefined</code> 与 <code>null</code> 是可以赋值到其他类型的（string/num…）,否则，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</p><p>b. <code>number</code> 和 <code>bigint</code> 都是表示数字，但是这两个类<code>相互不兼容的</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">98</span>, <span class="hljs-number">29</span>)<br><br><span class="hljs-keyword">let</span> sub = (<span class="hljs-attr">num1</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">num2</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> num1 - num2<br>&#125;<br><span class="hljs-title function_">sub</span>(<span class="hljs-number">98</span>, <span class="hljs-number">29</span>)<br><br><span class="hljs-comment">// 函数重载</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Types</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: Types, b: Types</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>() + b.<span class="hljs-title function_">toString</span>()<br>  &#125;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="特别的类型"><a href="#特别的类型" class="headerlink" title="特别的类型"></a>特别的类型</h4><h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><blockquote><p>表示的是那些永不存在的值的类型</p></blockquote><p>两种情况：</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 异常</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">err</span>(<span class="hljs-params">msg: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg)<br>&#125;<br><br><span class="hljs-comment">// 死循环</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loopForever</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-comment">// OK</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>特别用法：</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 利用 never 类型的特性来实现全面性检查</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">controlFlowAnalysisWithNever</span>(<span class="hljs-params">foo: Foo</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 string 类型</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 这里 foo 被收窄为 number 类型</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// foo 在这里是 never</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">check</span>: <span class="hljs-built_in">never</span> = foo<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 假如哪一天Foo新增boolean，ts就会抛出一个产生一个编译错误。确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span><br><span class="hljs-comment">// 使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</span><br></code></pre></div></td></tr></table></figure><h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><blockquote><p>unknown<code>与</code>any<code>的最大区别是： 任何类型的值可以赋值给</code>any<code>，同时</code>any<code>类型的值也可以赋值给任何类型。</code>unknown<code> 任何类型的值都可以赋值给它，但它只能赋值给</code>unknown<code>和</code>any</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用typeof、类型断言等方式来缩小未知范围：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDogName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: unknown<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">const</span> dogName = <span class="hljs-title function_">getDogName</span>()<br><span class="hljs-comment">// 直接使用</span><br><span class="hljs-keyword">const</span> upName = dogName.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// Error</span><br><span class="hljs-comment">// typeof</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dogName === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  <span class="hljs-keyword">const</span> upName = dogName.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// OK</span><br>&#125;<br><span class="hljs-comment">// 类型断言</span><br><span class="hljs-keyword">const</span> upName = (dogName <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// OK</span><br></code></pre></div></td></tr></table></figure><h5 id="Number、String、Boolean、Symbol"><a href="#Number、String、Boolean、Symbol" class="headerlink" title="Number、String、Boolean、Symbol"></a>Number、String、Boolean、Symbol</h5><blockquote><p>首先，我们来回顾一下初学 TypeScript 时，很容易和原始类型 number、string、boolean、symbol 混淆的首字母大写的 Number、String、Boolean、Symbol 类型，后者是相应原始类型的<code>包装对象</code>，姑且把它们称之为对象类型。</p></blockquote><p>从类型兼容性上看，原始类型兼容对应的对象类型，反过来对象类型不兼容对应的原始类型。</p><p>下面我们看一个具体的示例：</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Num</span>: <span class="hljs-title class_">Number</span><br><span class="hljs-title class_">Num</span> = num <span class="hljs-comment">// ok</span><br>num = <span class="hljs-title class_">Num</span> <span class="hljs-comment">// ts(2322)报错</span><br></code></pre></div></td></tr></table></figure><p><strong>此，我们需要铭记不要使用对象类型来注解值的类型，因为这没有任何意义。</strong></p><h5 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h5><blockquote><p>另外，object（首字母小写，以下称“小 object”）、Object（首字母大写，以下称“大 Object”）和 {}（以下称“空对象”）</p></blockquote><p>小 object 代表的是所有非原始类型，也就是说我们不能把 number、string、boolean、symbol 等 原始类型赋值给 object。在严格模式下，<code>null</code> 和 <code>undefined</code> 类型也不能赋给 object。</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// object</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">lowerCaseObject</span>: <span class="hljs-built_in">object</span><br>lowerCaseObject = <span class="hljs-number">1</span> <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">true</span> <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">null</span> <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// ts(2322)</span><br>lowerCaseObject = &#123;&#125; <span class="hljs-comment">// ok</span><br></code></pre></div></td></tr></table></figure><p>大 Object 代表所有拥有 toString、hasOwnProperty 方法的类型，所以所有原始类型、非原始类型都可以赋给 Object。同样，在严格模式下，null 和 undefined 类型也不能赋给 Object。</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// Object</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">upperCaseObject</span>: <span class="hljs-title class_">Object</span><br>upperCaseObject = <span class="hljs-number">1</span> <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-literal">true</span> <span class="hljs-comment">// ok</span><br>upperCaseObject = <span class="hljs-literal">null</span> <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// ts(2322)</span><br>upperCaseObject = &#123;&#125; <span class="hljs-comment">// ok</span><br></code></pre></div></td></tr></table></figure><p><strong>综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</strong></p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><blockquote><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedStr</span>: <span class="hljs-string">&#x27;this is string&#x27;</span> = <span class="hljs-string">&#x27;this is string&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedNum</span>: <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">specifiedBoolean</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>应用场景：</p><p>比如声明如下所示的一个类型 Config：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">interface <span class="hljs-title class_">Config</span> &#123;<br>  <span class="hljs-attr">size</span>: <span class="hljs-string">&#x27;small&#x27;</span> | <span class="hljs-string">&#x27;big&#x27;</span>;<br>  <span class="hljs-attr">isEnable</span>: <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>;<br>  <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> | <span class="hljs-number">2</span> | <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意 :</p><p>在缺省类型注解的情况下，TypeScript 推断出它的类型直接由赋值字面量的类型决定</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;this is string&#x27;</span> <span class="hljs-comment">// str: &#x27;this is string&#x27;</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span> <span class="hljs-comment">// num: 1</span><br><span class="hljs-keyword">const</span> bool = <span class="hljs-literal">true</span> <span class="hljs-comment">// bool: true</span><br></code></pre></div></td></tr></table></figure><h3 id="02-ts-专业名词-🧐"><a href="#02-ts-专业名词-🧐" class="headerlink" title="02 ts 专业名词 🧐"></a>02 ts 专业名词 🧐</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><blockquote><p>在很多情况下，TypeScript 会根据上下文环境自动推断出变量的类型，无须我们再写明类型注解。</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;I am a string&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 简化后 -----&gt;</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;I am a string&#x27;</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>我们把 TypeScript 这种基于赋值表达式推断类型的能力称之为<code>类型推断</code></p><p>在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。比如我们能根据 return 语句推断函数返回的类型，如下代码所示：</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">/** 根据参数的类型，推断出返回值的类型也是 number */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">const</span> x1 = <span class="hljs-title function_">add1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 推断出 x1 的类型也是 number</span><br><br><span class="hljs-comment">/** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">const</span> x2 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> x3 = <span class="hljs-title function_">add2</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">// ts(2345) Argument of type &quot;1&quot; is not assignable to parameter of type &#x27;number | undefined</span><br></code></pre></div></td></tr></table></figure><p>但！如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-attr">arrayNumber</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> <span class="hljs-attr">greaterThan2</span>: <span class="hljs-built_in">number</span> = arrayNumber.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num &gt; <span class="hljs-number">2</span>) <span class="hljs-comment">// 提示 ts(2322),有可能是 undefinded 或 number</span><br><br><span class="hljs-comment">// 加入类型检测</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">arrayNumber</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> <span class="hljs-attr">greaterThan2</span>: <span class="hljs-built_in">number</span> = arrayNumber.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span> <span class="hljs-comment">// ok</span><br></code></pre></div></td></tr></table></figure><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: string = <span class="hljs-string">&quot;我是string&quot;</span><br><span class="hljs-comment">// 相当于跳过类型检测</span><br><span class="hljs-comment">// 01 尖括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: number = &lt;number&gt;str;<br><span class="hljs-comment">// 02 as 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: number = str <span class="hljs-keyword">as</span> number;<br></code></pre></div></td></tr></table></figure><h5 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h5><p>在上下文中当类型检查器无法断定类型时,可以使用 <code>&quot;!&quot;</code>断言操作对象非 null 或 undefined</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 示例1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | string;<br>str.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// error</span><br>str!.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// ok</span><br><span class="hljs-comment">// 示例2</span><br>type <span class="hljs-title class_">Foo</span> = <span class="hljs-function">() =&gt;</span> number<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFun</span>(<span class="hljs-params">foo: Foo || <span class="hljs-literal">undefined</span></span>) &#123;<br>    <span class="hljs-title function_">foo</span>();<span class="hljs-comment">// error</span><br>    foo!(); <span class="hljs-comment">//ok</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h5><p>允许在实例属性和变量声明后面放置一个 <code>&quot;!&quot;</code> 号,从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: number;<br><span class="hljs-title function_">initialize</span>();<br><br><span class="hljs-comment">// Variable &#x27;x&#x27; is used before being assigned.(2454) 很明显该异常信息是说变量 x 在赋值前被使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">// 解决该问题，我们可以使用确定赋值断言：</span><br><span class="hljs-keyword">let</span> x!: number;<br><span class="hljs-title function_">initialize</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> * x); <span class="hljs-comment">// Ok</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"></span>) &#123;<br>  x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p><h4 id="类型拓宽（Type-Widening）"><a href="#类型拓宽（Type-Widening）" class="headerlink" title="类型拓宽（Type Widening）"></a>类型拓宽（Type Widening）</h4><h4 id="类型缩小（Type-Narrowing）"><a href="#类型缩小（Type-Narrowing）" class="headerlink" title="类型缩小（Type Narrowing）"></a>类型缩小（Type Narrowing）</h4><h3 id="03-编译选项-tsconfig-json💕"><a href="#03-编译选项-tsconfig-json💕" class="headerlink" title="03 编译选项 tsconfig.json💕"></a>03 编译选项 tsconfig.json💕</h3><h4 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h4><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>示例： [path1,path2…]</p><p>作用：规定需要编译的路径</p><h5 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h5><p>示例： [path1,path2…]</p><p>作用：排除规定不需要编译的路径</p><h5 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a><a href="https://www.tslang.cn/docs/handbook/compiler-options.html">compilerOptions</a></h5><p>常见的编译选项：</p><table><thead><tr><th>选项</th><th>类型</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>target</td><td>string</td><td>“ES3”</td><td>指定<code>ECMAScript</code>目标版本</td></tr><tr><td>module</td><td>string</td><td>target === “ES6” ? “ES6” : “commonjs”</td><td>指定生成哪个模块系统代码</td></tr><tr><td>lib</td><td>string[]</td><td></td><td>编译过程中需要引入的库文件的列表。</td></tr><tr><td>outDir</td><td>string</td><td></td><td>重定向输出目录。</td></tr><tr><td>outFile</td><td>string</td><td></td><td>将输出文件合并为一个文件。</td></tr><tr><td>removeComments</td><td>boolean</td><td>false</td><td>编译后移除注释</td></tr><tr><td>allowJs</td><td>boolean</td><td>false</td><td>是否编译 js 文件</td></tr><tr><td>checkJs</td><td>boolean</td><td>false</td><td>在 <code>.js</code>文件中报告错误。与 <code>--allowJs</code>配合使用。</td></tr><tr><td>noEmitOnError</td><td>boolean</td><td>false</td><td>编译，但不生成编译后的文件</td></tr><tr><td>noEmitOnError</td><td>boolean</td><td>false</td><td>报错时不生成输出文件</td></tr><tr><td>alwaysStrict</td><td>boolean</td><td>false</td><td>以严格模式解析并为每个源文件生成 <code>&quot;use strict&quot;</code>语句</td></tr><tr><td>noImplicitAny</td><td>boolean</td><td>false</td><td>在表达式和声明上有隐含的 <code>any</code>类型时报错。</td></tr></tbody></table><h3 id="03-使用-webpack-打包-ts-代码-📦"><a href="#03-使用-webpack-打包-ts-代码-📦" class="headerlink" title="03 使用 webpack 打包 ts 代码 📦"></a>03 使用 webpack 打包 ts 代码 📦</h3><h4 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-comment">// HTML模板, 自动将打包好的模块得引入到 html内</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-comment">// 自动清理 dist 文件目录下的老文件</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 开发模式下</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  <span class="hljs-comment">// 入口</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,<br>  <span class="hljs-comment">// 出口</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">environment</span>: &#123;<br>      <span class="hljs-comment">// 用于兼容 IE 浏览器</span><br>      <span class="hljs-attr">arrowFunction</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// 模块</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      <span class="hljs-comment">// 用于解析 ts 文件格式规则</span><br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-comment">// 配置 Babel</span><br>          &#123;<br>            <span class="hljs-comment">// loder</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>            <span class="hljs-comment">// 设置 babel</span><br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-comment">// 设置预定义得环境</span><br>              <span class="hljs-attr">presets</span>: [<br>                [<br>                  <span class="hljs-comment">// 指定环境得插件</span><br>                  <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>                  <span class="hljs-comment">// 配置信息</span><br>                  &#123;<br>                    <span class="hljs-comment">// 需要兼容目标浏览器</span><br>                    <span class="hljs-attr">targets</span>: &#123;<br>                      <span class="hljs-attr">ie</span>: <span class="hljs-number">11</span>,<br>                    &#125;,<br>                    <span class="hljs-comment">// 指定core.js的版本</span><br>                    <span class="hljs-attr">corejs</span>: <span class="hljs-string">&#x27;3&#x27;</span>,<br>                    <span class="hljs-comment">// 使用corejs方式 &quot;usage&quot;,表示按需加载</span><br>                    <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&#x27;usage&#x27;</span>,<br>                  &#125;,<br>                ],<br>              ],<br>            &#125;,<br>          &#125;,<br>          <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>        ],<br>        <span class="hljs-comment">// 排除的文件</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>      &#125;,<br>    ],<br>  &#125;,<br><br>  <span class="hljs-comment">// 配置 Webpack 插件</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>((options = &#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;)),<br>  ],<br><br>  <span class="hljs-comment">// 配置 webpack-dev-server</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">static</span>: &#123;<br>      <span class="hljs-attr">directory</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>),<br>    &#125;,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8081</span>,<br>  &#125;,<br><br>  <span class="hljs-comment">// 用来设置引用模块</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// 扩展 ts 可以使用模块</span><br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 Gitlab, Github, Gitee 的环境</title>
    <link href="/2022/02/15/%E9%85%8D%E7%BD%AE%20Gitlab,%20Github,%20Gitee%20%E7%9A%84%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/02/15/%E9%85%8D%E7%BD%AE%20Gitlab,%20Github,%20Gitee%20%E7%9A%84%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="配置-Gitlab-Github-Gitee-的环境"><a href="#配置-Gitlab-Github-Gitee-的环境" class="headerlink" title="配置 Gitlab, Github, Gitee 的环境"></a>配置 Gitlab, Github, Gitee 的环境</h2><h3 id="01-问题描述："><a href="#01-问题描述：" class="headerlink" title="01 问题描述："></a>01 问题描述：</h3><p>使用 Hexo 搭建播客，遇到一个问题，Github 和 Gitlab 的用户名和邮箱都不一样，所以每次代码 push,邮箱和用户名都得改了改去。因此就需要配置三者共存的 Git 环境。</p><h3 id="02-解决问题："><a href="#02-解决问题：" class="headerlink" title="02 解决问题："></a>02 解决问题：</h3><p>下面这个链接是我在网上找到的不错的解决方案。</p><p><a href="https://www.cnblogs.com/tooyi/p/13677190.html">配置 github 和 gitee(码云)的 Git 环境</a></p><h3 id="03-补充-config-文件常见配置项："><a href="#03-补充-config-文件常见配置项：" class="headerlink" title="03 补充 config 文件常见配置项："></a>03 补充 config 文件常见配置项：</h3><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#配置示例</span><br><span class="hljs-comment">#Host 后面是别名</span><br><span class="hljs-comment">#HostName 为IP</span><br><span class="hljs-comment">#Port为端口</span><br><span class="hljs-comment">#User为用户名</span><br><span class="hljs-comment">#IdentityFile为自己ID私钥</span><br><span class="hljs-comment">#PreferredAuthentications publickey  # 首选认证方式</span><br></code></pre></div></td></tr></table></figure><p>示例：</p><blockquote><p>aa 公司</p><p>gitlab 地址：http:// xx.xx.xx.xx</p><p>email: <a href="mailto:&#120;&#x69;&#x61;&#111;&#x6d;&#x69;&#x6e;&#103;&#x40;&#x61;&#97;&#x2e;&#x63;&#x6f;&#109;">&#120;&#x69;&#x61;&#111;&#x6d;&#x69;&#x6e;&#103;&#x40;&#x61;&#97;&#x2e;&#x63;&#x6f;&#109;</a></p><p>name: xiaoming</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#gitLab</span><br>Host xx.xx.xx.xx<br>HostName xx.xx.xx.xx<br>User xiaoming<br>    IdentityFile ~/.ssh/id_rsa.gitlab<br>    PreferredAuthentications publickey<br></code></pre></div></td></tr></table></figure><p>测试一下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh -T git@xx.xx.xx.xx<br>// OK: Welcome to GitLab, @xiaoming!<br></code></pre></div></td></tr></table></figure><p>结尾：</p><p>在项目 git 仓库下,定义自己的 <code>用户名</code> 和 <code>email</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;xiaoming&quot;</span><br><br>$ git config --<span class="hljs-built_in">local</span> user.email <span class="hljs-string">&quot;xiaoming@aa.com&quot;</span><br></code></pre></div></td></tr></table></figure><p>最后就可以愉快提交代码了…</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
